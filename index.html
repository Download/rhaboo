<!DOCTYPE html>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8'>
<meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9, minimum-scale=0.9" />
<html class='no-js'>
  <title>Rhaboo : JS Persistence Library</title>  
  <link rel="shortcut icon" type="image/png" href="logo.png" />

  <style>
html > *                     { font-family: Arial !important; color: #502000; background-color: white;}
table, tr                    { vertical-align: top;}
h2, h1                       { text-decoration: underline; }
.cssvwunit     .banner       { vertical-align: bottom; font-size: 15vw; font-weight:bold; margin-left:0px;text-align:right;}
.no-cssvwunit  .banner       { vertical-align: bottom; font-size: 75px; font-weight:bold; margin-left:0px;text-align:right;}
.cssvwunit .subbanner1       { vertical-align: bottom; font-size: 2.5vw; margin-left:0.30em;text-align:right;}
.no-cssvwunit .subbanner1    { vertical-align: bottom; font-size: 13px; margin-left:0.30em;text-align:right;}
.cssvwunit .subbanner2       { vertical-align: bottom; font-size: 2.5vw; text-align:right;}
.no-cssvwunit .subbanner2    { vertical-align: bottom; font-size: 13px; text-align:right;}
.cssvwunit .topmenuitem      { text-align:center; vertical-align: bottom; font-size: 3.5vw; margin-left:0.30em;}
.no-cssvwunit .topmenuitem   { text-align:center; vertical-align: bottom; font-size: 18px; margin-left:0.30em;}
.cssvwunit .secmenuitem      { text-align:center; vertical-align: bottom; font-size: 2.5vw; margin-left:0.30em;}
.no-cssvwunit .secmenuitem   { text-align:center; vertical-align: bottom; font-size: 13px; margin-left:0.30em;}
.cssvwunit .splash, 
.cssvwunit th                { text-align:center; font-size: 2.5vw;}
.no-cssvwunit .splash, 
.no-cssvwunit th             { text-align:center; font-size: 18px;}
.cssvwunit .splashof3        { font-weight:bold; text-align:center; font-size: 3vw;}
.no-cssvwunit .splashof3     { font-weight:bold; text-align:center; font-size: 15px;}
.cssvwunit .detailof3        { padding-left:1vw; padding-right:1vw; text-align:center; font-size: 1.5vw;}
.no-cssvwunit .detailof3     { padding-left:1vw; padding-right:1vw; text-align:center; font-size: 11px;}




.cssvwunit body              { font-size:1.5vw}
.no-cssvwunit body           { font-size:11px}

dt                           { font-weight: bold;}

.boxshadow .boxof3           { box-shadow: 5px 8px 18px 2px #502000; -webkit-box-shadow: 5px 10px 15px #502000; -moz-box-shadow: 5px 10px 15px #502000; width:30% }
.menu                        { table-layout: fixed; background-color:#ffffa0; }
a.plain:link                 { text-decoration: none; color: #502000;} 
a.plain:visited              { text-decoration: none; color: #502000;} 
a.plain:hover                { text-decoration: none; color: #502000;} 
a.plain:active               { text-decoration: none; color: #502000;} 

#api td, #api th             { padding-left: 10px; padding-right: 10px; }
#api dt                      { font-weight:normal; }
#history td, #history th     { font-size:100%; text-align:left; padding-left: 10px; padding-right: 10px; }
#history dt                  { font-weight:normal; }

  </style>

  <script src='rhaboo.min.js'></script>
  <script src='modernizr.custom.42785.js'></script>
  <script>

function vis(name, v) {
  if (name) {
    var ob = document.getElementById(name);
    ob.style.fontWeight=v?"bold":"";
    ob.style.textShadow=v?"-1px 2px #C0C060":"";
    document.getElementById(name.toUpperCase()).style.display=v?"block":"none";
  }
}

var store = new Rhaboo.Persistent("RhabooHomePage");

function show1(x) {
  vis(store.showing1, false);
  store.write('showing1', x) ;
  vis(store.showing1, true)
}

function show2(x) {
  vis(store.showing2, false);
  store.write('showing2', x) ;
  vis(store.showing2, true)
}

function start() {
  if (!store.showing1) {
    store.write('showing1', 'about') ;
    store.write('showing2', 'demos') ;
  }
  vis(store.showing1, true)
  vis(store.showing2, true)
}

  </script>

<body onload="start();">

    <table width='100%'>
      <tr width='100%'>
        <td width='30%'> <img src='logo.png' width='100%'/> </td>
        <td style='vertical-align: bottom;'>
          <table width='100%'>
            <tr><td class='subbanner1'>Makes JavaScript objects persistent...</td></tr>
            <tr><td class='subbanner2'>...without learning a new API.</td></tr>
            <tr><td class='banner'>rhaboo</td></tr>
          </table>
          <!--
            <span class='subbanner1'>Makes JavaScript objects persistent...</span><br/>
            <span class='subbanner2'>...without learning a new trick.</span><br/>
            <span class='banner'>rhaboo</span><br/>
          -->
        </td>
      </tr>
    </table>
    <table  class='menu' width='100%'><tr width='100%'>
        <td class='topmenuitem' id='about' onClick='show1(this.id);'>about</td>
        <td class='topmenuitem' id='docs' onClick='show1(this.id);'>docs</td>
        <td class='topmenuitem' id='faq' onClick='show1(this.id);'>faq</td>
        <td class='topmenuitem'><a class='topmenuitem plain' href="https://github.com/adrianmay/rhaboo">github</a></td>
        <!--
        <td class='topmenuitem' onClick='window.location.href="https://github.com/adrianmay/rhaboo"'>github</td>
        -->
      </tr>
    </table>
    <div id='ABOUT' style='display:none;'> 
      <p class='splash'>The easiest, fastest and most portable persistence solution on the web</p>
    <table style='vertical-align:top;' width='100%'>
      <tr style='vertical-align:top;'>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Easy</p>
          <p class='detailof3'>Makes regular JS objects persistent. <br/><br/>No new storage paradigm to learn.
        </td>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Full</p>
          <p class='detailof3'>Stores objects nested to any level. <br/><br/>All standard array functions work persistently. <br/><br/>Supports non-numeric properties of arrays.
        </td>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Fast</p>
          <p class='detailof3'>Stores components of objects separately rather than just stringifying and parsing the whole thing at every little change. <br/><br/>Writes to disk in a background thread.
        </td>
        <td></td>
      </tr></table>
        <br/>
      <table style='vertical-align:top;'><tr style='vertical-align:top;'>
        <td></td>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Portable</p>
          <p class='detailof3'>Only relies on localStorage.
        </td>
        <td></td>
        <td class='boxof3'>
          <p class='splashof3'>Reliable</p>
          <p class='detailof3'>Our automatically generated test script contains roughly 40,000 assertions.
        </td>
        <td></td>
        <td></td>
      </tr>
    </table>     
     
    <br/>
     <p>For instance:
      <pre>
&lt;script src='rhaboo.min.js'&gt;&lt;/script&gt;
&lt;script&gt;
  <span style='color:green;'>//Open a persistent object called 'Some name'...</span>
  <b>var store = new Rhaboo.Persistent('Some name');</b>
  <span style='color:green;'>//If it has a property called 'count' then increment it, </span>
  <span style='color:green;'>//otherwise initialise it to 1...</span>
  <b>store.write('count', store.count ? store.count+1 : 1);</b>
&lt;/script&gt;
&lt;body onLoad='
  document.getElementById("count").
    <span style='color:green;'>//Use it like a normal object...</span>
    <b>innerHTML = store.count</b>;'&gt;
  &lt;p&gt;You loaded this page &lt;span id='count'&gt;&lt;/span&gt; times.
&lt;/body&gt;
      </pre>
      <p>So having made <code>store</code> with that constructor, it behaves just like a normal object except that wherever you'd normally write <code>store.key=val</code> you should write <code>store.write('key', val)</code> instead. Furthermore, any objects or arrays inside a persistent one also have that <code>write</code> function: 
      <br/>
      <br/>
      <pre>
store.write('somethingfancy', {
  one: ['man', 'went'],
  2: 'mow',
  went: [  2, { mow: ['a', 'meadow' ] }, {}  ]
});

store.somethingfancy.went[1].mow.write(1, 'lawn');
      </pre>
      <p>That is quite literally all you need to know.

      <table width='100%'>
        <tr>
          <td></td>
          <td class='boxof3'>
            <a class='download plain' href="https://raw.githubusercontent.com/adrianmay/rhaboo/master/rhaboo.min.js" download><div class='splashof3' style='padding-top:50px; padding-bottom:50px; '>Download</div></a>
          <p class='detailof3'>rhaboo.min.js
          </td>
          <td></td>
        </tr>
      </table>
      <br/>
      <p class='splash'>Free and Open Source.</p>
      <center>
        <script data-gratipay-username="adrianmay"
                data-gratipay-widget="button"
                src="//gttp.co/v1.js"></script>
        <table>
          <tr>
            <td>
              <img width='25px' height='25px' src=bitcoin.png></img>1YF83SfzgR8ZjjuMe9RdFvFkc78UFwEn9
            </td>
          </tr>
        </table>
      </center>
      <br/>
    </div>
    <div id='DOCS' style='display:none;'> 
      <table  class='menu' width='100%'><tr width='100%'>
          <td class='secmenuitem' id='install' onClick='show2(this.id);'>install</td>
          <td class='secmenuitem' id='demos' onClick='show2(this.id);'>demos</td>
          <td class='secmenuitem' id='reference' onClick='show2(this.id);'>reference</td>
          <td class='secmenuitem' id='internals' onClick='show2(this.id);'>internals</td>
          <td class='secmenuitem' id='tests' onClick='show2(this.id);'>tests</td>
        </tr>
      </table>
      <div id='INSTALL' style='display:none;'> 
        <p>There are several options:
        <ol>
          <li>Just grab <a href='https://raw.githubusercontent.com/adrianmay/rhaboo/master/rhaboo.min.js'>rhaboo.min.js</a> and put the script tag in your document.<br/><br/></li>         
          <li>In the directory where your html is:<pre>npm install rhaboo</pre> then write a script tag pointing at node_modules/rhaboo/rhaboo.min.js<br/><br/></li>         
            <li>If you want to edit and build rhaboo then do this:<pre>
npm install grunt rhaboo
cd node_modules/rhaboo
npm install q grunt-contrib-uglify grunt-browserify seedrandom ajon
grunt    # be patient with this
            </pre></li>         
        </ol>
      </div>
      <div id='DEMOS' style='display:none;'> 
        <p><a class='subbanner1 plain' href='index.html'>This web page uses rhaboo (around line 70) to remember where you were in the menus</a> 
        <p><a class='subbanner1 plain' href='demos/counter.html'>Reload counter</a> 
        <p><a class='subbanner1 plain' href='demos/cliches.html'>Simple database</a> 
        <p><a class='subbanner1 plain' href='demos/game.html'>Tiles game</a> 
      </div>
      <div id='REFERENCE' style='display:none;'> 
        <table id='api' width='100%'>
          <tr><td colspan=4><hr/></td></tr>
          <tr>
            <th width='33%'>API</th>
            <th>Description</th>
            <th>Parameters</th>
            <th>Returns</th>
          </tr>
          <tr><td colspan=4><hr/></td></tr>
          <tr>
            <td><code>new Rhaboo.Persistent(name)</code></td>
            <td>Constructor of root persistent object. Best performance is obtained if there's only one of these. The library looks for entries in localStorage corresponding with the passed name and loads any previously persisted data into the returned object. If no data is found, a mostly empty object is returned, mostly meaning that it just has a property called _rhaboo which is used for internal purposes.</td>
            <td>
              <dt>name:</dt><dd>Any text name that's not likely to be the same as any other.</dd> 
            </td>
            <td>The persistent object.</td>
          </tr>
          <tr><td colspan=4><hr/></td></tr>
          <tr>
            <td><code>Object.prototype.write(key, val)</code></td>
            <td>Persistent replacement for = operator. <code>store.write('key',val)</code> is equivalent to <code>store.key=val </code>except with persistence. Can be applied to objects inside the root persistent as well as the root persistent itself.</td>
            <td>
              <dt>this:</dt><dd>The object whose property we're adding or changing</dd> 
              <dt>key:</dt><dd>The property name within <code>this</code></dd> 
              <dt>val:</dt><dd>The new value for the property. Any javascript type is acceptable, but functions and regexes will not persist.</dd> 
            </td>
            <td><code>this</code></td>
          </tr>
          <tr><td colspan=4><hr/></td></tr>
          <tr>
            <td><code>Object.prototype.kill(key)</code></td>
            <td>Persistent equivalent of <code>delete object.key</code>. Completely removes a property. This is not the same as setting it to undefined. Don't use it on arrays. Use splice instead.</td>
            <td>
              <dt>this:</dt><dd>The object whose property we're adding or changing</dd> 
              <dt>key:</dt><dd>The property name within <code>this</code></dd> 
            </td>
            <td><code>this</code></td>
          </tr>
          <tr><td colspan=4><hr/></td></tr>
        </table>
        <h1>Version History</h1>
        <p>Warning: rhaboo uses semver, so a major version change WILL be a breaking change. Make sure you specify the major version you are coding against and use the latest within that range.
        
<table id='history' width='100%'>
<tr>
  <th>Version</th>
  <th>Changes</th>
</tr>
<tr>       <td>2.0.5</td>          <td>First anybody has heard of</td>          </tr>
<tr>       <td>2.0.6</td>          <td>Code cleanup: Remove where from _rhaboo</td>          </tr>
</table>

      </div>
      <div id='TESTS' style='display:none;'> 
        <p>This will erase any data in the demo apps...
        <p><a href='http://adrianmay.github.io/rhaboo/generate-tests/generated-pages/page.0.html'>Run tests</a>
        <!--
        <iframe width='100%' height='10000px' src='http://adrianmay.github.io/rhaboo/generate-tests/generated-pages/page.0.html'></iframe>
        -->
      </div>
      <div id='INTERNALS' style='display:none;'>
        <p>Rhaboo has 3 source files: <ul>
          <li>enq.js which depends on the promises library called q</li>
          <li>core.js which depends on enq.js</li>
          <li>arr.js which depends on core.js</li>
        </ul><p>There's also a huge test script generator which depends on another repo by the same author called ajon. This is a more accurate but less readable version of JSON. Rhaboo itself does not use ajon, only the test script generator does.
        <h2>enq.js</h2>
        <p>This uses q to provide a simple job queue to be performed in a single background thread. The jobs are performed in the order they were requested. It provides a function <code>enq</code> which should be used as follows:
        <pre>
function step(def) {
  //do some work
  def.resolve();
}
 
enq(step);
        </pre>
        <p>The code in enq.js is just basic q usage, so the documentation of q should be consulted for help with it.
        <p>enq.js also allows a callback to be registered which will be told when the queue becomes full or empty. It's very slow and not especially reliable. Unless a better method comes along, it'll be deprecated.
        <h2>core.js</h2>
        <h3>Use of local storage</h3>
        <p>Here's a peep into the localStorage usage of the cliches demo:
        <p><center><img src='peep.png'></center></img>
        <p>Points to notice include:<ul>
          <li>The vertical bars make parsing easier with JS's String.split function.</li>
          <li>A # suffix indicates an array while an &amp; indicates any other object.</li>
          <li>After a # there's usually a number, which is an index within the previously named array.</li>
          <li>The value of the entry provides the type and the value as a string</li>
          <li>When the value contains only a |, the purpose is to declare an object or array. This isn't necessary if we can rely on finding a child of the object or array (which would declare it implicitly,) but some are empty.</li>
          <li>The order in which these entries are retrieved doesn't matter because we can create parent paths on demand.</li>
          <li>Lengths of arrays are stored explicitly so we can recreate trailing undefinedes.</li>
          <li>The key notation is embodied in the function Object.prototype._rhaboo_childKey</li>
        </ul>
        <h3>Type stuff</h3>
        <p>Rhaboo often wants to know if something is an array, another object, or a leaf. To this end there are some simple functions near the start of core.js. Around the same place is the treatment of hasOwnProperty so it doesn't return true for _rhaboo (that's where this library keeps its per-object data,) which helps best-practice iterations of objects and arrays behave sensibly. 
        <h3>Backgrounding</h3>
        <p>Rhaboo eases load on the <code>q</code> layer by building a script of all the <code>localStorage</code> operations required to persist a given change, and enqueuing a single <code>.then</code> job to perform the whole script. For instance, in <code>_rhaboo_persist</code>, a blank script called <code>ss</code> is declared and populated by passing it to functions in <code>forgetters</code> and <code>stashers</code>. Those functions use <code>intend</code> to push instructions onto the script, so <code>intend</code> embodies the backgrounding policy. The populated script is passed to <code>procrastinate</code> which uses <code>enq</code> as previously described. The work inside the job that <code>procrastinate</code> enqueues is to run thrugh the script and apply each step in turn to <code>localStorage</code>.
        <h3>The central functions</h3>
        <pre>

                                                
         _rhaboo_unpersist          ______        
        /                 \        /      \            
       /                   \      |     _rhaboo_forget 
      /                     \     V    /
  kill                       forgetters --[leaf]
                            /          \        \
                           /            [leaf] --\
                          /                       localStorage    
          _rhaboo_persist           ______           
        /                 \        /      \       
       /                   \      |     _rhaboo_stash
      /                     \     V    /                
 write                        stashers  --[leaf]   
                                       \        \  
                                        [leaf] --\ 
                                                  localStorage

        </pre>
        <p>The heart of rhaboo is a pair of recursive processes: one for remembering things and the other for forgetting them. These are embodied by stashers[] and Object.prototype._rhaboo_stash() on the one hand and forgetters[] and Object.prototype._rhaboo_forget() on the other. stashers[] and forgetters[] are maps from the type of the thing to remember or forget to a function for doing it. For leaf types, it's a direct instruction to localStorage; for objects, it's a call to _rhaboo_stash or _rhaboo_forget which deal with the per-se localStorage entry for the object and its length entry, then recurse back into stashers[] or forgetters[] for each of its properties. 
        <p>stashers[] and forgetters[] are the only callers of _rhaboo_stash() and _rhaboo_forget() respectively, and are themselves originally called by Object.prototype._rhaboo_persist and Object.prototype._rhaboo_unpersist. _rhaboo_unpersist only calls forgetters[] but _rhaboo_persist calls both. Just like write and kill, these functions are called with this equal to the parent of the property being changed. Unless this is marked as persistent by having the _rhaboo property, they do nothing. If _rhaboo is present, they figure out a localStorage key for the child property and use forgetters[] to erase any old localStorage entries and perhaps also stashers[] to create new ones. 
        <p>The reader might have remarked that in order to forget a complex object from localStorage, that object still has to exist in memory so we know what was in it. (One could alternatively iterate the whole of localStorage and look for matching keys but that would be slower on large data sets.) On the other hand, we promised to return the UI thread quickly. The required procedure, then, is to make a note of the old value, assign the new one to the object in memory, queue a job to forget the old and remember the new values, and then return the UI thread. That is exactly what is written in write and kill, and they do the queueing using _persist and _unpersist.
        <h3>Constructor and restoration</h3>
        <p>The constructor Rhaboo.Persistent merely calls Object.prototype._rhaboo_restore with the passed name. The job here is to run through localStorage in a random order, filter on keys that match the passed name, create any parents implied by early parts of the key, recreate the types and values of leaves from the values of localStorage entries, and populate any data used by rhaboo itself.
        <h2>arr.js</h2>
        <p>This is where the 7 array operations: push, pop, shift, unshift, splice, sort and reverse (plus maybe fill if it's available) are made persistent. The original functions are stashed and used by the new persistent ones. 
        <p>In the worst case scenario that the array is totally rewritten, e.g. by a sort, our strategy is to make a complete copy of the old array, call the original function, then do something like _rhaboo_persist which  forgets the old version and remembers the new. This is rather slow.
        <p>For push and pop we can do a lot better because we know that most of the array is unaffected. The push strategy is to note the length of the array before and after the push, then individually remember each element between the old and new lengths. We also need to remember the new length. Popping is easier because we know the length shrank by 1 and because the original pop obligingly gives us the old value to forget. 
        <h2>Modules, namespaces, etc</h2>
        <p>Each source file uses node.js-style modularisation: the important exports are written in something called module.exports which acquires a local name when 'require'd by another module. For instance, within enq.js, the enq function is called enq, but because core.js imports it as "E" it must be referred to as E.enq in that file. 
        <p>Browsers don't have a require statement so the 'Browserify' preprocessor is used to read them and output a source file combining all the modules. 
        <p>It's not desirable to force people to use Browserify, so there's also a source file that uses Browserify to import arr.js (which exports everything useful) and assigns it to a regular variable called Rhaboo. A non-user of browserify can import this to reach rhaboo. Functions that live in Object.prototype or Array.prototype are available without that unbrowserification.
        <p>Namespace pollution is restricted to names beginning with _rhaboo (except write and kill) and the Rhaboo object. 
        <h2>Test Automation</h2>
        <p>Seeing as this library is about persistence, the test script has to run over multiple pages.
        <p>The test system consists of a grunt task in generate-tests/tasks/gentest.js that writes a set of html pages, each accompanied by a JS file containing a test script. These end up in generate-tests/generated-pages. The test script is a JS object to be interpreted by the page with the help of generate-tests/runner.js. 
        <p>Let's look at some script:
        <pre>
var page = 0;
var persistents = {
   "P1000001": [
      {
         "action": "write",
         "path": [
            "P1000002"
         ],
         "vehicle": "{&lt;val&gt;=[(5):&lt;0&gt;=(2);&lt;1&gt;=!;&lt;2&gt;=&lt;blah&gt;;&lt;3&gt;=[(3):&lt;0&gt;=(3);&lt;1&gt;=@;&lt;2&gt;=&lt;ecky&gt;;];&lt;4&gt;={&lt;a&gt;=&lt;asdf&gt;;&lt;b&gt;=@;};];}",
         "expect": "{&lt;P1000002&gt;=[(5):&lt;0&gt;=(2);&lt;1&gt;=!;&lt;2&gt;=&lt;blah&gt;;&lt;3&gt;=[(3):&lt;0&gt;=(3);&lt;1&gt;=@;&lt;2&gt;=&lt;ecky&gt;;];&lt;4&gt;={&lt;a&gt;=&lt;asdf&gt;;&lt;b&gt;=@;};];}"
      },
        </pre>
        <p>The hieroglyphics in <code>vehicle</code> and <code>expect</code> are a notation called ajon which is like JSON but more accurate and less readable.
        <p>The instruction is to open a root persistent called P1000001, write to its property called P1000002 a value of [2,false,'blah',[3, true, 'ecky' ],{ a:'asdf', b:true }] and then expect P1000001 to contain just that. After all, this is the first instruction in the whole test script and runner.js will erase localStorage before starting. There are more changes to P1000001 on this and subsequent pages so <code>expect</code> will often contain data left over from earlier actions. Actions are not always writes - they can also be array operations or kills.
        <p>gentest.js works by making up a series of actions, applying them to normal objects in memory and writing the contents of those objects after each operation into the expect field. The runner works by repeating the same sequence over a number of pages and checking the results against the expect field. If persistence is working properly, the page breaks should have no effect.
        <p>The script, then, is a list of pages, each containing a list of root persistents, each containing a list of action-expect steps. But that's not how it gets designed. Rather, we start with a reasonably versatile list of 'stories' as to what a given property might experience. The model for that is three operations, each optionally followed by a page break, and each being either a kill or a write using a specified type. With 8 types (string or bool, number, empty object, populated object, empty array, populated array, undefined, null) that makes 9*2*9*2*9*2=5832 different stories including 2.5*5832=14580 page breaks. The first step of gentest.js is to calculate these stories and store them in a random order. 
        <p>The next step is to hand the stories out to a range of root persistents and sub-objects thereof. We make variables for the current target persistent and target path within it, then step through the stories and 'episodes' of the stories, writing script steps that apply each episode to the current target (i.e. whatever is in the current persistent along the current path,) fill in values for the parameters of the write episodes, and bump the target around as we go along. That bumping around includes at each step a certain probability of: starting a whole new persistent, diving deeper into the current target if it is an object, popping up to the current target's parent, or skipping to a sibling. When reading that code, one should note that the current path doesn't need to point at something that exists because we're about to write it anyway.
        <p>This is a script that we can actually run on normal JS objects to get the expected values. But it's got about 15000 pages and only one persistent on each. So we separate the script of each persistent from every other, then reallocate them to pages in parallel. Now the number of pages equals the length of the longest per-persistent script, and the first page is the busiest. Unfortunately this leads to a geometric distribution of persistents over pages with a ludicrously long tail of very short pages towards the end, so we clip that by modifying the handing-out process to forcibly hop to a new persistent if there have been too many page breaks while this persistent was target. 
        <p>It only remains to write the actual html and JS files for each page.
        <p>Array support got added to this automat as an afterthought. The solution was to reinterpret the episode codes when there's an array in the current target. There's a 50/50 chance that they are still interpreted as usual, but they may be taken to refer to array functions instead. So the code that normally means "write a number" might now mean "pop".
      </div>
    </div>
    <div id='FAQ' style='display:none;'> 
      <dl>
        <dt>Why is it called rhaboo? </dt>
        <dd><p>Because nothing else is, not in any language. </dd>
        <dt>Why an owl?</dt>
        <dd><p>Because proboscis monkeys aren't that pretty after all.</dd>
        <br/>
        <dt>What licence is it released under?</dt>
        <dd><p>MIT</dd>
        <dt>How do I get support?</dt>
        <dd><p>You can create an issue on github or ask a question on stackoverflow. Please create the <code>rhaboo</code> tag if you can.</dd>
        <br/>
        <dt>How fast is it?</dt>
        <dd><p>Proper performance tests are in the pipeline, but it must be very fast because localStorage is a simple mechanism and it's being used in a very efficient way. However, those array functions like reverse and sort which change the whole thing are a bit slow right now.</dd>
        <dt>What can't it do?</dt>
        <dd>
        <p>Function-valued and regex-valued properties of objects are ignored. If you want regexes just ask. You can add an object with a funny prototype to a persistent and it'll behave ok during this run, but the prototype won't be restored on the next run.
        <p>Don't put any object into two persistent places. Each persistent object has one property recording where in localStorage it lives. If you put it into another persistent place this will be overwritten. If your app needs a lot of cross-referencing among persistent objects, use their names or the like.
        <p>There's no protection for the case that the user closes the window while background persistence jobs are still going on. For most programs this is highly unlikely because you won't be firing off huge persistence jobs, but if it is a concern, you can roll your own journalling checks. For instance, you'll gradually write the new version of the sub-object in a temporary place, atomically write that it's the important one, and then gradually delete the old one. The UI thread will have returned to responsiveness much earlier than this. If there's demand for rhaboo to do this kind of thing itself, then it'll be developed.</dd>
        <dt>What can it do that most libraries can't?</dt>
        <dd><p>Most libraries either force you to learn a new storage paradigm or limit themselves to single-level maps like what localStorage already gives you. 
        <p>Some libraries store multi-level objects by stringifying and parsing the whole thing, but that's very slow if you just want to add a thousandth element to a list. Furthermore, they suffer the limitations of JSON, namely, that non-numerically named properties of arrays are dropped and sparse entries are filled with nulls. This is very different from objects or arrays in memory where null, undefined and non-existent are all different states for a property. This causes hard to diagnose bugs.
        <p>Other libraries switch between underlying persistence mechanisms according to what the browser can do, but there's no advantage in that for the programmer. You still have to decide whether your program is so simple that raw localStorage will do, or so complex that you'll need WebSQL polyfill, or somewhere in between. You have to decide what paradigm you want to think in, and having done so, you'll want a library that does exactly that and no more.  
        <p>The overwhelming advantage of rhaboo is that by simply replacing your assignments with <code>write</code> calls one-to-one, you can completely forget about the whole persistence issue.</dd>
        <dt>Why do I need to use <code>store.write('key', val)</code> instead of just <code>store.key=val</code>?</dt>
        <dd><p>Because there's no way of overriding assignment in the case that <code>key</code> is something new.</dd>
        <dt>Why do I end up cloning your web site when I only wanted to clone the library?</dt>
        <dd><p>They work togther very intimately so keeping them on different branches is just too much hassle.</dd>
        <dt></dt>
        <dd></dd>
        <dt></dt>
        <dd></dd>
        
      </dl>
    </div>
